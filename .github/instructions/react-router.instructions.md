# React Router 7

## Critical: Route Type Imports

**THE MOST IMPORTANT RULE: ALWAYS use `./+types/[routeName]` for route type imports.**

```tsx
// CORRECT - ALWAYS use this pattern:
import type { Route } from './+types/product-details';
import type { Route } from './+types/product';
import type { Route } from './+types/category';

// NEVER use relative paths like this:
// import type { Route } from "../+types/product-details";  // WRONG!
// import type { Route } from "../../+types/product";       // WRONG!
```

**If you see TypeScript errors about missing `./+types/[routeName]` modules:**

1. **IMMEDIATELY run `npm run typecheck`** to generate the types
2. **Or start the dev server** which will auto-generate types
3. **NEVER try to "fix" it by changing the import path**

---

## Type Generation & Workflow

- **Run `npm run typecheck` after adding/renaming any routes**
- **Run `npm run typecheck` if you see missing type errors**
- Types are auto-generated by `@react-router/dev` in `./+types/[routeName]` relative to each route file
- **The dev server will also generate types automatically**

---

## Package Guidelines

### Correct Packages:

- `react-router` - Main package for routing components and hooks
- `@react-router/dev` - Development tools and route configuration
- `@react-router/node` - Node.js server adapter
- `@react-router/serve` - Production server

### NEVER Use:

- `react-router-dom` - Legacy package, use `react-router` instead
- `@remix-run/*` - Old packages, replaced by `@react-router/*`
- React Router v6 patterns - Completely different architecture

---

## Route Configuration

**This project uses config-based routing.** All routes are defined in `app/routes.ts` as a single source of truth.

### Basic Configuration

```ts
// app/routes.ts
import { type RouteConfig, route, index, layout, prefix } from '@react-router/dev/routes';

export default [
    index('./home.tsx'),
    route('about', './about.tsx'),

    layout('./auth/layout.tsx', [
        route('login', './auth/login.tsx'),
        route('register', './auth/register.tsx'),
    ]),

    ...prefix('concerts', [
        index('./concerts/home.tsx'),
        route(':city', './concerts/city.tsx'),
        route('trending', './concerts/trending.tsx'),
    ]),
] satisfies RouteConfig;
```

---

## Route Modules

The files referenced in `routes.ts` define each route's behavior through exports.

### Standard Pattern

```tsx
import type { Route } from './+types/product';
import { data, redirect } from 'react-router';

// Server data loading
export async function loader({ params }: Route.LoaderArgs) {
    return { product: await getProduct(params.id) };
}

// Form handling
export async function action({ request }: Route.ActionArgs) {
    const formData = await request.formData();
    await updateProduct(formData);
    return redirect('/products');
}

// Component - access data via props
export default function Product({ loaderData }: Route.ComponentProps) {
    return <div>{loaderData.product.name}</div>;
}
```

**ALWAYS destructure in the function signature:**

```ts
// CORRECT
export async function action({ request }: Route.ActionArgs) {
    // ...
}

// WRONG - don't use intermediate variable
export async function action(args: Route.ActionArgs) {
    const { request } = args;  // Don't do this!
}
```

---

## Nested Routes

Routes can be nested inside parent routes. The parent's path is automatically included.

```ts
export default [
    route('dashboard', './dashboard.tsx', [
        index('./home.tsx'),           // /dashboard
        route('settings', './settings.tsx'),  // /dashboard/settings
    ]),
] satisfies RouteConfig;
```

### Rendering Children with Outlet

**Parent routes MUST use `<Outlet />` to render children:**

```tsx
import { Outlet } from 'react-router';

export default function Dashboard() {
    return (
        <div>
            <h1>Dashboard</h1>
            <Outlet />  {/* Renders matched child route */}
        </div>
    );
}
```

**Common mistake:** Forgetting `<Outlet />` means child routes won't render.

---

## Layout Routes

Layout routes create nesting **without adding URL segments**. Perfect for shared UI and middleware.

```ts
export default [
    layout('./marketing/layout.tsx', [
        index('./marketing/home.tsx'),      // /
        route('contact', './marketing/contact.tsx'),  // /contact
    ]),
] satisfies RouteConfig;
```

### Authentication Example

```ts
export default [
    route(Paths.SIGN_IN, 'routes/sign-in.tsx'),

    // Protected routes with auth middleware
    layout('routes/authenticated.tsx', [
        route(Paths.DASHBOARD, 'routes/dashboard.tsx'),
        route(Paths.PROFILE, 'routes/profile.tsx'),
    ]),
] satisfies RouteConfig;
```

```tsx
// routes/authenticated.tsx
import type { Route } from './+types/authenticated';
import { Outlet } from 'react-router';
import { authMiddleware } from '~/middleware/auth';

export async function loader(args: Route.LoaderArgs) {
    return authMiddleware(args);
}

export default function AuthenticatedLayout() {
    return <Outlet />;
}
```

---

## Index Routes

Index routes render at their parent's URL path (the "default" child).

```ts
export default [
    index('./home.tsx'),  // Renders at /

    route('dashboard', './dashboard.tsx', [
        index('./dashboard-home.tsx'),  // Renders at /dashboard
        route('settings', './dashboard-settings.tsx'),  // /dashboard/settings
    ]),
] satisfies RouteConfig;
```

**Index routes cannot have children** - they're leaf nodes.

---

## Route Prefixes

`prefix()` adds a path prefix **without creating a parent route**:

```ts
export default [
    ...prefix('projects', [
        index('./projects/home.tsx'),        // /projects
        route(':pid', './projects/project.tsx'),  // /projects/:pid
    ]),
] satisfies RouteConfig;
```

**Use `prefix()` for path organization. Use `layout()` when you need shared UI or middleware.**

---

## Dynamic Segments

Segments starting with `:` capture URL values:

```ts
route("teams/:teamId", "./team.tsx"),
```

```tsx
import type { Route } from './+types/team';

export async function loader({ params }: Route.LoaderArgs) {
    // params is typed: { teamId: string }
    const team = await getTeam(params.teamId);
    return { team };
}
```

### Multiple Dynamic Segments

```ts
route("c/:categoryId/p/:productId", "./product.tsx"),
```

```tsx
export async function loader({ params }: Route.LoaderArgs) {
    // params: { categoryId: string; productId: string }
}
```

---

## Optional Segments

Add `?` to make segments optional:

```ts
route(":lang?/categories", "./categories.tsx"),
```

```tsx
export async function loader({ params }: Route.LoaderArgs) {
    // params.lang is string | undefined
    const lang = params.lang || 'en';
    return { categories: await getCategories(lang) };
}
```

### Optional Static Segments

```ts
route('users/:userId/edit?', './user.tsx');
```

Matches both `/users/123` and `/users/123/edit`.

---

## Splat Routes (Catchall)

The `/*` pattern matches any characters including `/`:

```ts
route("files/*", "./files.tsx"),
```

```tsx
export async function loader({ params }: Route.LoaderArgs) {
    // /files/documents/2024/report.pdf
    // params["*"] = "documents/2024/report.pdf"
    const filePath = params['*'];
    return { file: await getFile(filePath) };
}
```

### 404 Catchall

```ts
export default [
    // ... your routes

    // Must be last
    route('*', './catchall.tsx'),
] satisfies RouteConfig;
```

```tsx
import { data } from 'react-router';

export function loader() {
    throw data('Page Not Found', { status: 404 });
}
```

---

## Type-Safe URL Generation

Use `href()` for type-safe dynamic URLs:

```tsx
import { Link, href } from "react-router";

// Static routes
<Link to={href("/products/new")}>New Product</Link>

// Dynamic routes with parameters
<Link to={href("/products/:id", { id: product.id })}>View</Link>

// In redirects
return redirect(href("/products/:id", { id: newProduct.id }));
```

**NEVER manually construct URLs:**

```tsx
// WRONG - no type safety
<Link to={`/products/${product.id}`}>Product</Link>
```

---

## Server vs Client Data Loading

```tsx
// Server-side rendering
export async function loader({ params }: Route.LoaderArgs) {
    return { product: await serverDatabase.getProduct(params.id) };
}

// Client-side navigation
export async function clientLoader({ params }: Route.ClientLoaderArgs) {
    return { product: await fetch(`/api/products/${params.id}`).then(r => r.json()) };
}

// Force client loader during hydration
clientLoader.hydrate = true;
```

---

## Streaming with Suspense

Return promises (don't await) for non-critical data:

```tsx
export async function loader({}: Route.LoaderArgs) {
    // Critical data - AWAIT (blocks render)
    const user = await getUserData();

    // Non-critical data - DON'T await (streams in)
    const analytics = getAnalyticsData();  // Returns Promise

    return { user, analytics };
}
```

```tsx
import * as React from 'react';
import { Await } from 'react-router';

export default function Dashboard({ loaderData }: Route.ComponentProps) {
    const { user, analytics } = loaderData;

    return (
        <div>
            <h1>Welcome, {user.name}</h1>

            <React.Suspense fallback={<div className="skeleton h-32 w-full" />}>
                <Await resolve={analytics}>
                    {(data) => <div>Views: {data.views}</div>}
                </Await>
            </React.Suspense>
        </div>
    );
}
```

---

## Navigation & Links

```tsx
import { Link, NavLink, useNavigate } from "react-router";

// Simple links
<Link to="/products">Products</Link>

// Active state styling
<NavLink to="/dashboard" className={({ isActive }) => isActive ? "active" : ""}>
    Dashboard
</NavLink>

// Programmatic navigation
const navigate = useNavigate();
navigate("/products");
```

### Fetchers for Non-Navigation Mutations

```tsx
import { useFetcher } from 'react-router';

function AddToCartButton({ productId }: { productId: string }) {
    const fetcher = useFetcher();

    return (
        <fetcher.Form method="post" action="/api/cart">
            <input type="hidden" name="productId" value={productId} />
            <button type="submit">
                {fetcher.state === 'submitting' ? 'Adding...' : 'Add to Cart'}
            </button>
        </fetcher.Form>
    );
}
```

---

## File Naming

Use **descriptive names** with **kebab-case**. The route configuration is the source of truth, not file names.

**NEVER use flat route naming with `$`:**

```text
BAD:
organizations.$slug.invitations.ts
organizations.$slug.settings.general.tsx

GOOD:
organizations/invitations.ts
organizations/settings/general.tsx
```

---

## Error Handling

```tsx
export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {
    if (isRouteErrorResponse(error)) {
        return (
            <div>
                <h1>{error.status} {error.statusText}</h1>
                <p>{error.data}</p>
            </div>
        );
    }

    return (
        <div>
            <h1>Oops!</h1>
            <p>{error.message}</p>
        </div>
    );
}
```

### Throwing from Loaders

```tsx
export async function loader({ params }: Route.LoaderArgs) {
    const product = await db.getProduct(params.id);
    if (!product) {
        throw data('Product Not Found', { status: 404 });
    }
    return { product };
}
```

---

## Anti-Patterns

### Don't use React Router v6 patterns:

```tsx
// WRONG
<Routes>
    <Route path="/" element={<Home />} />
</Routes>
```

### Don't fetch in components:

```tsx
// WRONG
function Product() {
    const [data, setData] = useState(null);
    useEffect(() => {
        fetch('/api/products');
    }, []);
    // Use loader instead!
}
```

### Don't handle forms manually:

```tsx
// WRONG
const handleSubmit = (e) => {
    e.preventDefault();
    fetch('/api/products', { method: 'POST' });
};
// Use Form component and action instead!
```

---

## Essential Rules Summary

1. **ALWAYS** import from `"./+types/[routeName]"` - never relative paths
2. **RUN `npm run typecheck`** when you see missing type errors
3. **ALWAYS** use `href()` for dynamic URLs
4. **LET TypeScript infer** loader/action return types
5. **USE `<Outlet />`** in parent/layout routes
6. **ADD** `.react-router/types/**/*` to `tsconfig.json` include array
