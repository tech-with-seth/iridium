## üö® CRITICAL: Route Type Imports - NEVER MAKE THIS MISTAKE

**THE MOST IMPORTANT RULE: ALWAYS use `./+types/[routeName]` for route type imports.**

```tsx
// ‚úÖ CORRECT - ALWAYS use this pattern:
import type { Route } from './+types/product-details';
import type { Route } from './+types/product';
import type { Route } from './+types/category';

// ‚ùå NEVER EVER use relative paths like this:
// import type { Route } from "../+types/product-details";  // WRONG!
// import type { Route } from "../../+types/product";       // WRONG!
```

**If you see TypeScript errors about missing `./+types/[routeName]` modules:**

1. **IMMEDIATELY run `typecheck`** to generate the types
2. **Or start the dev server** which will auto-generate types
3. **NEVER try to "fix" it by changing the import path**

## Type Generation & Workflow

- **Run `typecheck` after adding/renaming any routes**
- **Run `typecheck` if you see missing type errors**
- Types are auto-generated by `@react-router/dev` in `./+types/[routeName]` relative to each route file
- **The dev server will also generate types automatically**

---

## Critical Package Guidelines

### ‚úÖ CORRECT Packages:

- `react-router` - Main package for routing components and hooks
- `@react-router/dev` - Development tools and route configuration
- `@react-router/node` - Node.js server adapter
- `@react-router/serve` - Production server

### ‚ùå NEVER Use:

- `react-router-dom` - Legacy package, use `react-router` instead
- `@remix-run/*` - Old packages, replaced by `@react-router/*`
- React Router v6 patterns - Completely different architecture

## Essential Framework Architecture

### Route Configuration (`app/routes.ts`)

```tsx
import { type RouteConfig, index, route } from '@react-router/dev/routes';

export default [
    index('routes/home.tsx'),
    route('about', 'routes/about.tsx'),
    route('products/:id', 'routes/product.tsx', [
        index('routes/product-overview.tsx'),
        route('reviews', 'routes/product-reviews.tsx'),
    ]),
    route('categories', 'routes/categories-layout.tsx', [
        index('routes/categories-list.tsx'),
        route(':slug', 'routes/category-details.tsx'),
    ]),
] satisfies RouteConfig;
```

### Route Module Pattern (`app/routes/product.tsx`)

```tsx
import type { Route } from './+types/product';

// Server data loading
export async function loader({ params }: Route.LoaderArgs) {
    return { product: await getProduct(params.id) };
}

// Client data loading (when needed)
export async function clientLoader({ serverLoader }: Route.ClientLoaderArgs) {
    // runs on the client and is in charge of calling the loader if one exists via `serverLoader`
    const serverData = await serverLoader();
    return serverData;
}

// Form handling
export async function action({ request }: Route.ActionArgs) {
    const formData = await request.formData();
    await updateProduct(formData);
    return redirect(href('/products/:id', { id: params.id }));
}

// Component rendering
export default function Product({ loaderData }: Route.ComponentProps) {
    return <div>{loaderData.product.name}</div>;
}
```

DO NOT create a variable and destructure in this fashion:

```ts
export async function action(args: Route.ActionArgs) {
    const { request } = args;
    // relevant code here...
}
```

DO destructure `request` like this:

```ts
export async function action({ request }: Route.ActionArgs) {
    // relevant code here...
}
```

### Layout/Parent Routes with Outlet

**For layout routes that have child routes, ALWAYS use `<Outlet />` to render child routes:**

````tsx
import type { Route } from "./+types/categories-layout";
import { Outlet } from "react-router";

export default function CategoriesLayout(props: Route.ComponentProps) {
  return (
    <div className="layout">
      <nav>
        {/* Sidebar or navigation */}
      </nav>
      <main>
        <Outlet /> {/* ‚úÖ This renders the matching child route */}
      </main>
    </div>
  );
}

// ‚ùå Never use `children` from the component props, it doesn't exist
// export default function CategoriesLayout({ children }: Route.ComponentProps) {


## Automatic Type Safety & Generated Types

**React Router v7 automatically generates types for every route.** These provide complete type safety for loaders, actions, components, and URL generation.

### ‚úÖ ALWAYS Use Generated Types:
Types are autogenerated and should be imported as `./+types/[routeFileName]`. **If you're getting a type error, run `npm run typecheck` first.**

The filename for the autogenerated types is always a relative import of `./+types/[routeFileName]`:

```tsx
// routes.ts
route("products/:id", "routes/product-details.tsx")

// routes/product-details.tsx
// ‚úÖ CORRECT: Import generated types for each route
import type { Route } from "./+types/product-details";

export async function loader({ params }: Route.LoaderArgs) {
  // params.id is automatically typed based on your route pattern
  return { product: await getProduct(params.id) };
}

export default function ProductDetails({ loaderData }: Route.ComponentProps) {
  // loaderData.product is automatically typed from your loader return
  return <div>{loaderData.product.name}</div>;
}
````

### ‚úÖ Type-Safe URL Generation with href():

```tsx
import { Link, href } from "react-router";

// Static routes
<Link to={href("/products/new")}>New Product</Link>

// Dynamic routes with parameters - AUTOMATIC TYPE SAFETY
<Link to={href("/products/:id", { id: product.id })}>View Product</Link>
<Link to={href("/products/:id/edit", { id: product.id })}>Edit Product</Link>

// Works with redirects too
return redirect(href("/products/:id", { id: newProduct.id }));
```

### ‚ùå NEVER Create Custom Route Types:

```tsx
// ‚ùå DON'T create custom type files for routes
export namespace Route {
  export interface LoaderArgs { /* ‚ùå */ }
  export interface ComponentProps { /* ‚ùå */ }
}

// ‚ùå DON'T manually construct URLs - no type safety
<Link to={`/products/${product.id}`}>Product</Link> // ‚ùå
<Link to="/products/" + product.id">Product</Link> // ‚ùå
```

### Type Generation Setup:

- **Location**: Types generated in `./+types/[routeName]` relative to each route file
- **Auto-generated**: Created by `@react-router/dev` when you run dev server or `npm run typecheck`
- **Comprehensive**: Covers `LoaderArgs`, `ActionArgs`, `ComponentProps`, `ErrorBoundaryProps`
- **TypeScript Config**: Add `.react-router/types/**/*` to `include` in `tsconfig.json`

## Critical Imports & Patterns

### ‚úÖ Correct Imports:

```tsx
import { Link, Form, useLoaderData, useFetcher, Outlet } from 'react-router';
import { type RouteConfig, index, route } from '@react-router/dev/routes';
import { data, redirect, href } from 'react-router';
```

## Data Loading & Actions

### Server vs Client Data Loading:

```tsx
// Server-side rendering and pre-rendering
export async function loader({ params }: Route.LoaderArgs) {
    return { product: await serverDatabase.getProduct(params.id) };
}

// Client-side navigation and SPA mode
export async function clientLoader({ params }: Route.ClientLoaderArgs) {
    return {
        product: await fetch(`/api/products/${params.id}`).then((r) =>
            r.json(),
        ),
    };
}

// Use both together - server for SSR, client for navigation
clientLoader.hydrate = true; // Force client loader during hydration
```

### Form Handling & Actions:

```tsx
// Server action
export async function action({ request }: Route.ActionArgs) {
    const formData = await request.formData();
    const result = await updateProduct(formData);
    return redirect(href('/products'));
}

// Client action (takes priority if both exist)
export async function clientAction({ request }: Route.ClientActionArgs) {
    const formData = await request.formData();
    await apiClient.updateProduct(formData);
    return { success: true };
}

// In component
<Form method="post">
    <input name="name" placeholder="Product name" />
    <input name="price" type="number" placeholder="Price" />
    <button type="submit">Save Product</button>
</Form>;
```

## Streaming with Suspense

React Router supports React Suspense for streaming non-critical data, allowing faster initial page renders by deferring slower data fetching.

### Return Promises from Loaders:

**Key Concept**: Return promises instead of awaiting them for non-critical data. React Router will await critical data but stream non-critical data.

```tsx
import type { Route } from './+types/dashboard';

export async function loader({}: Route.LoaderArgs) {
    // ‚úÖ Critical data - AWAIT this (blocks render)
    const user = await getUserData();

    // ‚úÖ Non-critical data - DON'T await (streams in later)
    const analytics = getAnalyticsData(); // Returns Promise<Analytics>
    const notifications = getNotifications(); // Returns Promise<Notification[]>

    // Return object with both awaited and promised data
    return {
        user, // Resolved value
        analytics, // Promise (streams)
        notifications, // Promise (streams)
    };
}
```

**‚ö†Ô∏è Important**: You cannot return a single promise - it must be an object with keys.

### Render with Suspense & Await:

```tsx
import * as React from 'react';
import { Await } from 'react-router';
import type { Route } from './+types/dashboard';

export default function Dashboard({ loaderData }: Route.ComponentProps) {
    const { user, analytics, notifications } = loaderData;

    return (
        <div>
            {/* ‚úÖ Critical data renders immediately */}
            <h1>Welcome, {user.name}</h1>

            {/* ‚úÖ Non-critical data shows fallback then streams in */}
            <React.Suspense fallback={<div className="skeleton h-32 w-full" />}>
                <Await resolve={analytics}>
                    {(data) => (
                        <div className="stats">
                            <div className="stat">
                                <div className="stat-title">Views</div>
                                <div className="stat-value">{data.views}</div>
                            </div>
                        </div>
                    )}
                </Await>
            </React.Suspense>

            <React.Suspense fallback={<div>Loading notifications...</div>}>
                <Await resolve={notifications}>
                    {(items) => (
                        <ul>
                            {items.map((item) => (
                                <li key={item.id}>{item.message}</li>
                            ))}
                        </ul>
                    )}
                </Await>
            </React.Suspense>
        </div>
    );
}
```

### React 19 Pattern with `use()`:

If using React 19, you can use `React.use()` instead of `<Await>`, but you need a separate component:

```tsx
import * as React from 'react';

export default function Dashboard({ loaderData }: Route.ComponentProps) {
    const { user, analytics } = loaderData;

    return (
        <div>
            <h1>Welcome, {user.name}</h1>

            <React.Suspense fallback={<div>Loading...</div>}>
                <AnalyticsDisplay promise={analytics} />
            </React.Suspense>
        </div>
    );
}

// Separate component to use React.use()
function AnalyticsDisplay({ promise }: { promise: Promise<Analytics> }) {
    const data = React.use(promise);
    return <div>Views: {data.views}</div>;
}
```

### Stream Timeout Configuration:

By default, React Router rejects pending promises after 4950ms. Configure in `entry.server.tsx`:

```tsx
// entry.server.tsx
export const streamTimeout = 10_000; // 10 seconds
```

### Best Practices:

1. **Use for slow/optional data**: Analytics, recommendations, comments, social data
2. **Don't use for critical UI**: User auth, page content, navigation data should be awaited
3. **Provide meaningful fallbacks**: Skeleton loaders, loading states, empty states
4. **Handle errors**: Wrap `<Await>` in error boundaries or use `errorElement` prop
5. **Consider user experience**: Don't stream too much data - it can feel janky

### Error Handling with Suspense:

```tsx
<React.Suspense fallback={<LoadingSkeleton />}>
    <Await
        resolve={slowData}
        errorElement={
            <div className="alert alert-error">Failed to load data</div>
        }
    >
        {(data) => <DataDisplay data={data} />}
    </Await>
</React.Suspense>
```

## Navigation & Links

### Basic Navigation:

```tsx
import { Link, NavLink } from "react-router";

// Simple links
<Link to="/products">Products</Link>

// Active state styling
<NavLink to="/dashboard" className={({ isActive }) =>
  isActive ? "active" : ""
}>
  Dashboard
</NavLink>

// Programmatic navigation
const navigate = useNavigate();
navigate("/products");
```

### Advanced Navigation with Fetchers:

```tsx
import { useFetcher } from 'react-router';

function AddToCartButton({ productId }: { productId: string }) {
    const fetcher = useFetcher();

    return (
        <fetcher.Form method="post" action="/api/cart">
            <input type="hidden" name="productId" value={productId} />
            <button type="submit">
                {fetcher.state === 'submitting' ? 'Adding...' : 'Add to Cart'}
            </button>
        </fetcher.Form>
    );
}
```

## File Organization & Naming

### ‚úÖ Flexible File Naming:

React Router v7 uses **explicit route configuration** in `app/routes.ts`. You are NOT constrained by old file-based routing conventions.

```tsx
// ‚úÖ Use descriptive, clear file names
export default [
    route('products', 'routes/products-layout.tsx', [
        index('routes/products-list.tsx'),
        route(':id', 'routes/product-details.tsx'),
        route(':id/edit', 'routes/product-edit.tsx'),
    ]),
] satisfies RouteConfig;
```

### File Naming Best Practices:

- Use **descriptive names** that clearly indicate purpose
- Use **kebab-case** for consistency (`product-details.tsx`)
- Organize by **feature** rather than file naming conventions
- The **route configuration** is the source of truth, not file names

### ‚ùå NEVER Use Flat Route Naming Convention

**BAD** - Flat route style with `$` for parameters:

```text
organizations.$slug.invitations.ts
organizations.$slug.members.ts
organizations.$slug.settings.general.tsx
```

**GOOD** - Directory-based organization:

```text
organizations/invitations.ts
organizations/members.ts
organizations/settings/general.tsx
```

**Critical Rules:**

1. **DO NOT** use `$` in file names - use kebab-case for dynamic segments
2. **DO NOT** give dynamic segments their own directory - organize by business logic/feature
3. **DO NOT** abbreviate directory names - spell out full words (use `organization-slug` not `org-slug`)
4. **DO NOT** namespace using periods - use directories instead (e.g., `slug/invitations.ts` not `slug.invitations.ts`)
5. **DO** leverage directories to organize related routes
6. **DO** add routes to `app/routes.ts` file with proper path configuration

**Examples:**

```text
‚ùå BAD - Period-based namespacing:
/api/organizations/slug.invitations.ts
/api/organizations/slug.members.ts

‚úÖ GOOD - Directory-based namespacing:
/api/organizations/slug/invitations.ts
/api/organizations/slug/members.ts
```

## Error Handling & Boundaries

### Route Error Boundaries:

Only setup `ErrorBoundary`s for routes if the users explicitly asks. All errors bubble up to the `ErrorBoundary` in `root.tsx` by default.

```tsx
export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {
    if (isRouteErrorResponse(error)) {
        return (
            <div>
                <h1>
                    {error.status} {error.statusText}
                </h1>
                <p>{error.data}</p>
            </div>
        );
    }

    return (
        <div>
            <h1>Oops!</h1>
            <p>{error.message}</p>
        </div>
    );
}
```

### Throwing Errors from Loaders/Actions:

```tsx
export async function loader({ params }: Route.LoaderArgs) {
    const product = await db.getProduct(params.id);
    if (!product) {
        throw data('Product Not Found', { status: 404 });
    }
    return { product };
}
```

## Advanced Patterns

### Pending UI & Optimistic Updates:

```tsx
import { useNavigation, useFetcher } from 'react-router';

// Global pending state
function GlobalSpinner() {
    const navigation = useNavigation();
    return navigation.state === 'loading' ? <Spinner /> : null;
}

// Optimistic UI with fetchers
function CartItem({ item }) {
    const fetcher = useFetcher();
    const quantity = fetcher.formData
        ? parseInt(fetcher.formData.get('quantity'))
        : item.quantity;

    return (
        <fetcher.Form method="post">
            <input
                type="number"
                name="quantity"
                value={quantity}
                onChange={(e) => fetcher.submit(e.currentTarget.form)}
            />
            {item.product.name}
        </fetcher.Form>
    );
}
```

### Progressive Enhancement:

```tsx
// Works without JavaScript, enhanced with JavaScript
export default function ProductSearchForm() {
    return (
        <Form method="get" action="/products">
            <input type="search" name="q" placeholder="Search products..." />
            <button type="submit">Search</button>
        </Form>
    );
}
```

## Anti-Patterns to Avoid

### ‚ùå React Router v6 Patterns:

```tsx
// DON'T use component routing
<Routes>
    <Route path="/" element={<Home />} />
</Routes>
```

### ‚ùå Manual Data Fetching:

```tsx
// DON'T fetch in components
function Product() {
    const [data, setData] = useState(null);
    useEffect(() => {
        fetch('/api/products');
    }, []);
    // Use loader instead!
}
```

### ‚ùå Manual Form Handling:

```tsx
// DON'T handle forms manually
const handleSubmit = (e) => {
    e.preventDefault();
    fetch('/api/products', { method: 'POST' });
};
// Use Form component and action instead!
```

## Essential Type Safety Rules

1. **ALWAYS** import from `"./+types/[routeName]"` - never use relative paths like `"../+types/[routeName]"`
2. **RUN `npm run typecheck`** when you see missing type errors - never try to "fix" the import path
3. **ALWAYS** use `href()` for dynamic URLs - never manually construct route strings
4. **LET TypeScript infer** loader/action return types - don't over-type returns
5. **USE Route.ComponentProps** for your route components - automatic loaderData typing
6. **ADD** `.react-router/types/**/*` to your `tsconfig.json` include array

## AI Assistant Guidelines

When working with React Router v7:

- **If you see missing `./+types/[routeName]` imports, ALWAYS suggest running `npm run typecheck` first**
- **NEVER suggest changing `./+types/[routeName]` to `../+types/[routeName]` or any other relative path**
- **After creating new routes, remind the user to run `npm run typecheck`**
- **Assume types need to be generated if they're missing, don't assume the dev server is running**
