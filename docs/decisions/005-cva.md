# 005: CVA (Class Variance Authority)

## Status

Accepted

## Context

We needed a solution for managing component variants that:

- Provides type safety for component props
- Handles complex variant combinations
- Works with Tailwind CSS
- Supports compound variants
- Maintains readability
- Reduces boilerplate
- Offers good developer experience

DaisyUI provides base components, but we need custom components with type-safe variants for specific use cases.

## Decision

We chose CVA (Class Variance Authority) for managing component variants.

CVA provides a type-safe way to create variant-based components with automatic TypeScript inference.

### Key Features

**Type-Safe Variants**:

```typescript
import { cva, type VariantProps } from "cva";

const buttonVariants = cva({
  base: "inline-flex items-center justify-center rounded-md",
  variants: {
    variant: {
      primary: "bg-primary text-primary-content",
      secondary: "bg-secondary text-secondary-content",
    },
    size: {
      sm: "h-9 px-3 text-sm",
      lg: "h-11 px-8 text-lg",
    },
  },
});

type ButtonProps = VariantProps<typeof buttonVariants>;
// variant: "primary" | "secondary"
// size: "sm" | "lg"
```

**Compound Variants**: Handle variant combinations:

```typescript
compoundVariants: [
  {
    variant: "primary",
    size: "lg",
    className: "font-bold",
  },
]
```

**Default Variants**: Set sensible defaults:

```typescript
defaultVariants: {
  variant: "primary",
  size: "md",
}
```

## Consequences

### Positive

- **Type Safety**: Full TypeScript support with automatic inference
- **Readability**: Clear, declarative variant definitions
- **Maintainability**: Centralized variant logic
- **Composability**: Easy to compose with other utilities
- **Small Size**: Minimal runtime overhead
- **DX**: Excellent autocomplete and type checking
- **Flexibility**: Works with any CSS-in-JS or utility library
- **No Runtime**: Compiles to simple class concatenation

### Negative

- **Learning Curve**: New API to learn
- **Verbosity**: More code than inline classes for simple components
- **Build Step**: Requires TypeScript compilation
- **Limited Scope**: Best for variant-based components

### Neutral

- **Not a UI Library**: Only handles class management
- **Tailwind Focused**: Works best with utility-first CSS
- **Component Layer**: Adds abstraction layer

## Alternatives Considered

### clsx/classnames

**Pros:**

- Simple API
- Widely used
- No learning curve
- Lightweight

**Cons:**

- No type safety
- Manual prop handling
- No variant system
- More boilerplate

**Why not chosen:** Lacks type safety and structured variant system.

### Vanilla Extract

**Pros:**

- Type-safe
- Build-time CSS
- Great performance
- Framework agnostic

**Cons:**

- Separate CSS files
- More complex setup
- Different paradigm
- Not Tailwind-focused

**Why not chosen:** More complex than needed. We prefer Tailwind utilities.

### Stitches

**Pros:**

- Type-safe variants
- Runtime CSS-in-JS
- Great DX
- Atomic CSS

**Cons:**

- Runtime overhead
- Not Tailwind-based
- Different styling approach
- Additional dependency

**Why not chosen:** Runtime CSS-in-JS adds overhead. CVA works with Tailwind.

### CSS Modules

**Pros:**

- Scoped styles
- No runtime
- Standard approach
- Good tooling

**Cons:**

- Separate files
- No variant system
- Manual composition
- Not utility-first

**Why not chosen:** Does not work well with Tailwind utilities.

### Styled Components

**Pros:**

- Popular
- Component-scoped
- Dynamic styling
- Large ecosystem

**Cons:**

- Runtime overhead
- Complex setup
- Not Tailwind-based
- SSR complexity

**Why not chosen:** Too heavy. Does not integrate with Tailwind.

### Inline Conditional Classes

**Pros:**

- No dependencies
- Simple
- Direct

**Cons:**

- No type safety
- Hard to maintain
- Verbose
- Error-prone

**Why not chosen:** Becomes unmaintainable for complex variants.

## Implementation Details

### Basic Component

```typescript
import { cva, type VariantProps } from "cva";

const buttonVariants = cva({
  base: "btn",
  variants: {
    variant: {
      primary: "btn-primary",
      secondary: "btn-secondary",
      ghost: "btn-ghost",
    },
    size: {
      sm: "btn-sm",
      md: "btn-md",
      lg: "btn-lg",
    },
  },
  defaultVariants: {
    variant: "primary",
    size: "md",
  },
});

type ButtonProps = VariantProps<typeof buttonVariants> & {
  children: React.ReactNode;
  onClick?: () => void;
};

function Button({ variant, size, children, onClick }: ButtonProps) {
  return (
    <button className={buttonVariants({ variant, size })} onClick={onClick}>
      {children}
    </button>
  );
}

// Usage
<Button variant="primary" size="lg">Click me</Button>
```

### With Tailwind Merge

```typescript
import { cva } from "cva";
import { twMerge } from "tailwind-merge";
import { clsx } from "clsx";

function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

const buttonVariants = cva({
  base: "btn",
  variants: { /* ... */ },
});

function Button({ variant, size, className, ...props }: ButtonProps) {
  return (
    <button
      className={cn(buttonVariants({ variant, size }), className)}
      {...props}
    />
  );
}

// Custom classes override variant classes
<Button variant="primary" className="rounded-full">
  Custom Button
</Button>
```

### Compound Variants

```typescript
const alertVariants = cva({
  base: "alert",
  variants: {
    variant: {
      info: "alert-info",
      error: "alert-error",
    },
    size: {
      sm: "text-sm p-2",
      lg: "text-lg p-4",
    },
  },
  compoundVariants: [
    {
      variant: "error",
      size: "lg",
      className: "font-bold border-2",
    },
  ],
});
```

### Configuration

```typescript
// app/cva.config.ts
import { defineConfig } from "cva";

export default defineConfig({
  hooks: {
    "cx:done": (classes) => twMerge(classes),
  },
});
```

## Usage Patterns

### When to Use CVA

- Custom reusable components
- Components with multiple variants
- Type-safe component APIs
- Complex variant combinations
- Shared component libraries

### When Not to Use CVA

- One-off components
- Simple styling without variants
- DaisyUI components (already styled)
- Static components without props

## Integration with DaisyUI

CVA complements DaisyUI:

- Use DaisyUI for standard components
- Use CVA for custom variants
- Combine DaisyUI classes with CVA
- Extend DaisyUI components with CVA

Example:

```typescript
const cardVariants = cva({
  base: "card bg-base-100 shadow-xl",
  variants: {
    bordered: {
      true: "border border-base-300",
    },
    hoverable: {
      true: "hover:shadow-2xl transition-shadow",
    },
  },
});
```

## Performance

- Zero runtime overhead in production
- Classes are concatenated at build time
- Works with PurgeCSS
- No style injection
- Minimal bundle impact

## References

- [CVA Documentation](https://cva.style/docs)
- [CVA Examples](https://cva.style/docs/examples)
- [Components Guide](../components.md)
- [DaisyUI Decision](./004-daisyui.md)
